| 항목 | 내용 |
|---|---|
| 문서 제목 | 코드 스타일 컨벤션 |
| 문서 목적 | 본 문서는 코드 스타일 컨벤션을 정의하여 코드 품질과 일관성을 유지하기 위한 문서이다 |
| 작성 및 관리 | BackendTeam |
| 최초 작성일 | 2026.01.18 |
| 최종 수정일 | 2026.01.18 |
| 문서 버전 | v1.0 |

<br>

---

# 코드 스타일 컨벤션

> 이 문서는 현재 프로젝트에서 사용하는 Spring 기반 코드/테스트 컨벤션을 한 곳에 정리한 참고 문서이다. 각 항목은 세부 컨벤션 문서를 요약한 것이며, 필요 시 원문 문서에서 세부 규칙을 확인한다.


## 목차

- [1. 코드 포맷(Spotless)](#1-코드-포맷spotless)
- [2. 네이밍과 레이어 규칙](#2-네이밍과-레이어-규칙)
- [3. 테스트 레이어와 책임](#3-테스트-레이어와-책임)
- [변경 이력](#변경-이력)

## 1. 코드 포맷(Spotless)

**핵심**: 커밋 전 Spotless 검사를 통과해야 한다.

- Eclipse 포매터 기반으로 동작
- 메인 모듈 루트의 `naver-eclipse-formatter.xml` 사용
- 네이버 캠퍼스 핵데이 Java 코딩 컨벤션 기반
- `spotless` Gradle 플러그인이 위 XML을 읽어 들이며 링크된 CSS/Kotlin 설정 없이 순수 Eclipse 룰과 `importOrder('java','javax','org','net','com')`, `removeUnusedImports()`를 적용중입니다. 검사 대상은 `src/**/*.java`입니다.

### 1.1 Import 순서 규칙

1. static
2. java
3. javax
4. org
5. net
6. com
7. ...

IntelliJ Import Order 설정값(예시):

```text
#;java;javax;org;net;com;;
```

### 1.2 Gradle 명령어

| 명령어 | 설명 |
| --- | --- |
| `./gradlew spotlessCheck` | 커밋 전 코드 포맷 검사 |
| `./gradlew spotlessApply` | 커밋 전 코드 포맷 적용 |
- Husky pre-commit 훅은 `./gradlew spotlessCheck`를 먼저 실행한 뒤 `./gradlew check -x test`를 호출하여 포맷 검사와 정적 검증을 순차적으로 수행합니다. (테스트는 Docker 기반이므로 임시로 제외)

### 1.3 IntelliJ IDE 설정

> 주의: IntelliJ는 자체 포매터 엔진을 사용하므로 추가 설정이 필요하다.

1. 플러그인 설치
   - `Adapter for Eclipse Code Formatter` 설치 및 활성화
2. 포매팅 파일 지정
   - `naver-eclipse-formatter.xml` 파일 경로 지정
3. Import 순서 설정
   - Import 순서 설정에 `#;java;javax;org;net;com;;` 입력

<br>

---

## 2. 네이밍과 레이어 규칙

**핵심**: 역할과 레이어가 이름에 드러나야 한다.

### 2.1 DTO 규칙

**기본 원칙**

- DTO는 기본적으로 Java `record`로 작성한다.
- DTO에 비즈니스 로직을 넣지 않는다(정규화/변환 정도만 허용).

**요청(Request) DTO**

- 의미: HTTP 입력(RequestBody/QueryParam)을 서비스가 이해할 수 있는 형태로 전달
- 네이밍: `{Domain}{UseCase}Request`
- 배치: `application.<context>.dto.request`
- 예시

```text
PostCreateRequest
CommentCreateRequest
PageSortRequest
```

**응답(Response) DTO**

- 의미: 컨트롤러 최종 응답 계약을 담는 DTO
- 네이밍: `{Domain}{UseCase}Response`
- 배치: `application.<context>.dto.response`
- 예시

```text
PostSummaryResponse
CommentResponse
PageResponse<T>
```

**조회용 모델(Condition / QueryDto)**

- 핵심 구분
  - `*Condition` = 조회 조건(입력)
  - `*QueryDto` = 조회 결과(출력/Projection)

**Condition (조회 조건/필터 입력)**

- 언제: Repository(특히 QueryDSL) 조회 시 검색 조건 묶음이 필요할 때
- 역할: 필터 파라미터를 한 덩어리로 전달 + 선택적으로 기본값/정규화 제공
- 네이밍: `{Domain}{UseCase}Condition`
- 배치: `domain.<context>.dto`
- 예시

```text
PostSearchCondition
CommentSearchCondition
MemberSearchCondition
```

**QueryDto (조회 결과/Projection 출력)**

- 언제: 엔티티 전체를 가져오기 부담될 때, 조인/집계 결과만 필요할 때
- 역할: QueryDSL/JPQL 결과를 담는 Projection DTO
- 네이밍: `{Domain}{UseCase}QueryDto`
- 배치: `domain.<context>.dto`
- 예시

```text
PostSummaryQueryDto
CommentQueryDto
MemberProfileQueryDto
```

**권장 / 비권장**

| 구분 | 권장 | 비권장 |
|---|---|---|
| 조회 조건 DTO | `*Condition` 사용 | `*QueryDto`로 네이밍 |
| 조회 결과 DTO | `*QueryDto` 사용 | `*Condition`으로 네이밍 |

**Query Repository (QueryDSL 기반 조회 전용)**

- 의미: `*Condition`을 입력으로 받아 QueryDSL 조회 후 `*QueryDto` 반환
- 배치
  - 인터페이스: `domain.<context>.repository`
  - 구현체: `domain.<context>.repository.impl`
- 네이밍(권장)

```text
PostQueryRepository + PostRepositoryImpl
CommentQueryRepository + CommentRepositoryImpl
```

**권장 흐름(가독성 기준)**

```text
Controller: *Request -> Service 호출
Repository: *Condition + Pageable -> *QueryDto(또는 Entity)
Service/Controller: *QueryDto -> *Response 변환
예) PostSearchCondition -> PostSummaryQueryDto -> PostSummaryResponse
```

**변환 메서드 네이밍(from/of/to)**

- 언제 필요한가
  - 같은 변환이 여러 곳에서 반복될 때
  - 생성 규칙/기본값/파생값이 있어 단순 생성으로 의도가 흐릴 때
- 권장 위치
  - Request DTO: `toXxx()`
  - Response DTO: `fromXxx(...)` 또는 `of(...)`
  - Condition DTO: `of(...)`, `empty()` 등 정적 팩토리
- 규칙
  - `toXxx()`는 반환 타입을 이름에 포함한다
  - `fromXxx(...)`는 입력 타입을 이름에 포함한다
  - 대표 생성 방식이면 `of(...)`를 사용한다
- 예시

```text
PageSortRequest.toPageable()
PostSummaryResponse.fromDto(PostSummaryQueryDto dto)
PostSearchCondition.of(keyword, memberId, tags)
PostSearchCondition.empty()
```

### 2.2 Entity 및 도메인 클래스

**핵심**: 상태 변경은 의미 있는 메서드로만 수행한다.

- Setter 금지: 상태 변경은 의미 있는 메서드로만 수행한다(`changeXxx`, `deactivate`, `withdraw` 등)
- 생성 통제: 외부 `new`/builder 호출을 막고 정적 팩토리(`create`)로 생성한다
- 검증은 생성/변경 시점에 즉시 수행한다

클래스 기본 템플릿(예시)

```java
@Entity
@Getter
@Builder(access = AccessLevel.PROTECTED)
@AllArgsConstructor(access = AccessLevel.PROTECTED)
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Table(name = "snake_case_table_name")
public class Post extends BaseTimeEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "title", nullable = false, length = 100)
    private String title;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private PostStatus status;

    public static Post create(String title) {
        validateCreate(title);
        return Post.builder()
                .title(title)
                .status(PostStatus.ACTIVE)
                .build();
    }

    public void changeTitle(String newTitle) {
        validateChangeTitle(newTitle);
        this.title = newTitle;
    }

    private static void validateCreate(String title) { /* ... */ }
    private static void validateChangeTitle(String title) { /* ... */ }
}
```

**필드/매핑 규칙**

- `@Table(name = "...")`, `@Column(name = "...")`은 snake_case를 사용한다
- ID는 `GenerationType.IDENTITY`를 기본으로 한다
- Enum은 `@Enumerated(EnumType.STRING)`를 사용한다
- 시간 타입은 `Instant`를 기본으로 한다
- `created_at`/`updated_at`은 `BaseTimeEntity` 등 공통 베이스로 관리한다

**메서드 네이밍(권장)**

```text
생성: create(...)
변경: changeXxx(...)
상태 전이: activate(), deactivate(), withdraw()
질의: isActive(), isDeleted()
```

**코드 순서(권장)**

```text
1) 필드 선언 (ID -> 일반 컬럼 -> Enum -> 시간)
2) 정적 팩토리(create)
3) 공개 비즈니스 메서드
4) private 검증/헬퍼 메서드
```

### 2.3 Validator와 Policy 구분

**핵심**: 형식/필수는 Validator, 비즈니스 규칙은 Policy가 담당한다.

- Validator = 요청이 시스템에 들어오기 전에 유효한가?
- Policy = 비즈니스적으로 허용되는 행동인가?

**배치(패키지)**

```text
Validator: application.<context>.validator
Policy: domain.<context>.policy
```

**네이밍 규칙**

```text
Validator 클래스: *Validator
Policy 클래스: *Policy
Validator 메서드: validate(...)
Policy 메서드(권장): validateCan[Action](...), should[Action](...)
```

**Service 호출 순서(권장)**

```text
1) Validator로 입력값/형식/존재성 검증
2) Policy로 도메인 규칙 검증
3) Entity는 불변식 유지
```

**예시**

```text
SignupValidator.validate(SignupRequest request)
PostCreateValidator.validate(PostCreateRequest request)
PostLikePolicy.validateCanLike(Post post, Member member)
ViewCountPolicy.shouldCount(Long postId, ViewContext context)
```

**권장 / 비권장**

| 구분 | 권장 | 비권장 |
|---|---|---|
| Validator | 형식/필수/범위/존재성 검증 | 비즈니스 룰 포함 |
| Policy | 소유권/상태 전이/한도/금지 규칙 | Request DTO 직접 의존 |

### 2.4 보안/인프라 네이밍

**핵심**: 기존 컴포넌트 확장 여부로 `Custom` 사용을 결정한다.

- Spring Security 기본 컴포넌트 확장/구현 시 `Custom` 접두어 사용
- 신규 타입은 기능 중심 이름으로 작성

**네이밍 패턴**

```text
기존 클래스 확장: Custom + <원본 클래스/역할>
예) CustomLoginAuthenticationFilter
예) CustomAuthenticationEntryPoint
예) CustomAccessDeniedHandler

신규 구현(기능명): <기능><역할>
예) FilterChainExceptionFilter
예) LoginSuccessHandler, LoginFailureHandler
예) LogoutHandler
```

**권장 / 비권장**

| 구분 | 권장 | 비권장 |
|---|---|---|
| Custom 사용 | 기존 타입 확장/구현 시 | 모든 보안 컴포넌트에 무조건 적용 |
| 신규 타입 | 상황/기능이 드러나는 이름 | 역할이 불명확한 네이밍 |

### 2.5 API 계약: 페이징

**핵심**: 요청/응답 형태를 표준화하여 모든 API가 동일한 규칙을 따른다.

- 구성 요소
  - 요청: `PageSortRequest` (page/size/sort)
  - 상수: `PaginationConstants` (기본 page/size/sort)
  - 응답: `PageResponse<T>` (공통 페이지 응답)

**레이어 책임**

```text
Controller: PageSortRequest -> toPageable() 변환
Service: Pageable 기반으로 조회만 수행
Repository: Pageable 기반 정렬/조회 수행
```

**응답 스키마(고정 필드)**

```text
items, page, size, totalElements, totalPages
```

**권장 / 비권장**

| 구분 | 권장 | 비권장 |
|---|---|---|
| 응답 | PageResponse<T> 우선 사용 | 도메인별 목록 응답을 별도 생성 |
| 변환 | Controller에서 변환 종료 | Service가 웹 요청 DTO 의존 |

<br>

---

## 3. 테스트 레이어와 책임

**핵심**: 테스트 목표와 검증 범위를 레이어마다 분리한다.

### 3.1 레이어 역할 요약

**통합 테스트 (`@IntegrationTest`, `@IntegrationSecurityTest`)**

- 목표: 운영과 유사한 컨텍스트에서 전체 플로우 검증
- 검증 대상: Controller -> Service -> Repository -> DB -> (테스트용) Security/인프라
- 제외: 모든 HTTP 계약 세부 필드, 모든 분기/경계값
- 형태: Given(데이터 저장) / When(MockMvc 호출) / Then(상태 코드 + 핵심 필드 + DB 상태)

**컨트롤러 WebMvc 테스트 (`@ControllerWebMvcTest`)**

- 목표: HTTP 계약(Request/Response/Validation/예외 매핑) 고정
- 검증 대상: 매핑/바인딩/Validation/예외 응답/공통 응답 래퍼 구조
- 제외: 서비스/도메인 로직, JPA 동작
- 형태: Given(Service Mock) / When(MockMvc) / Then(status + jsonPath)

**서비스 단위 테스트 (`@UnitTest`)**

- 목표: 서비스의 오케스트레이션/분기/예외 검증
- 검증 대상: 협력자 호출 순서/조건, 예외 흐름, 계산/조합 로직
- 제외: HTTP 계약, JPA 동작, 실제 보안 설정
- 형태: `@Mock` + `@InjectMocks` + Given/When/Then

**레포지토리 테스트 (`@RepositoryJpaTest`)**

- 목표: JPA 매핑/쿼리 동작 검증
- 검증 대상: 매핑/연관관계/soft delete 조건/커스텀 쿼리
- 제외: 서비스 규칙, HTTP 계약
- 형태: Given(데이터 저장) / When(쿼리 1회) / Then(결과/부작용)

### 3.2 Fixture 사용 규칙

**공통 규칙**

- Fixture는 유효한 기본 상태와 반복 제거가 목적이다
- Fixture는 공용 소스셋(`src/testFixtures/java`)에 둔다
- 네이밍은 `대상 + Fixture`로 고정한다

```text
PostFixture
MemberFixture
PostRequestFixture
PostQueryDtoFixture
```

**레이어별 사용 규칙**

- Domain 테스트
  - SUT 엔티티는 가급적 실제 `create(...)`로 생성한다
  - 협력 엔티티만 Fixture로 만든다
- Repository 테스트
  - 저장 전 엔티티는 Fixture로 만든다(`create(...)` 위주)
  - 조회 결과는 DB에서 실제로 나온 값으로 검증한다
- Service 단위 테스트
  - Given 단계에서 Request/Entity Fixture를 적극 사용한다
  - Then 단계에서 Response는 핵심 필드를 직접 assert한다
- Controller WebMvc 테스트
  - Request DTO는 Fixture로 만들고, Response는 `jsonPath`로 계약을 검증한다
- Integration 테스트
  - Given은 Fixture + 실제 Repository 저장
  - When은 MockMvc 호출
  - Then은 DB 상태를 실제 조회로 검증한다

<br>

---

## 변경 이력

| 버전 | 일자 | 작성자 | 변경 내역 | 비고 |
|---|---|---|---|---|
| v1.0 | 2026.01.18 | BackendTeam | 문서 초안 작성 | - |
