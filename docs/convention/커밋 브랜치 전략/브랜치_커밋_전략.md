| 항목 | 내용 |
|---|---|
| 문서 제목 | 브랜치 / 커밋 전략 |
| 문서 목적 | 본 문서는 브랜치, PR, 커밋, Git Hook 규칙을 표준화하여 협업 품질과 일관성을 확보하기 위한 문서이다 |
| 작성 및 관리 | BackendTeam |
| 최초 작성일 | 2026.01.18 |
| 최종 수정일 | 2026.01.18 |
| 문서 버전 | v1.0 |

<br>

---

# 브랜치 / 커밋 전략

## 1. 브랜치 모델

Git-Flow 기반으로 운영합니다.

| **브랜치** | **역할** |
| --- | --- |
| `main` | 운영(프로덕션) 배포 브랜치 — **보호/직접 Push 금지** |
| `develop` | 개발 통합 브랜치 — **보호/직접 Push 금지** |
| `feat/*` | 기능 개발 브랜치 |
| `refactor/*` | 기능 변화 없는 코드 정리 |
| `hotfix/*` | 운영 긴급 수정 |

---

## 2. 규칙

### 2.1 하나의 브랜치 = 하나의 이슈

- 큰 작업은 반드시 세분화하여 여러 `feat/*`로 나눈다.

### 2.2 main / develop 직접 커밋 금지

- 모든 병합은 PR + 리뷰 + CI 통과 후 진행.

### 2.3 브랜치 네이밍

```
type/이슈ID/스코프-간단설명

예)
    - feat/#123/user-auth
    - refactor/reservation-query-#98
    - hotfix/booking-npe-#210
```

### 2.4 머지 전략

- 기본: **Squash & Merge** (히스토리 압축)
- hotfix/release: **Merge Commit**
- develop 브랜치는 상황에 따라 일반 merge 허용

---

# 🚀 Pull Request 규칙

## 1. 제목

```
type: 요약(한글)
예) feat: 사용자 API 1차 구현
```

---

## 2. 대상 브랜치

- 일반 기능: `feat/*` → `develop`
- 핫픽스: `hotfix/*` → `main` (반드시 `develop`에도 역머지)

---

## 3. PR 본문 필수 항목

1. **배경/의도**
2. **주요 변경사항** (목록)
3. **스키마/API 변경 여부**
4. **테스트 방법** (재현 스텝 포함)
5. **성능 영향/마이그레이션**
6. **연관 이슈** (`Closes #123`)

---

## 4. 머지 조건

- CI 전체 통과
- 보호 브랜치 Required reviewers 충족
- 충돌 해결 & 최신화 확인

---

# ✅ 커밋 전략

## 1. 커밋 메시지 규칙

- `Type` (필수): Commit의 종류. 커밋 시 type에 상응하는 이모지가 자동으로 붙습니다.
- `Scope` (선택): Commit의 범위. 기능, 함수, 페이지, API 등 자유롭게 선택합니다.
- `Subject` (필수): Commit의 제목. 간결하게 작성하고 명사형 어미로 끝냅니다.
- `Body` (선택): Commit의 내용. 어떤 이유로, 어떻게 변경했는지 작성합니다.
- `Footer` (선택): Commit의 추가 정보. 이슈 트래킹이나 참고 사항을 기록합니다.

**메시지 구조**

```bash
<type>(optional scope): <subject>

[optional body]

[optional footer(s)]
```

**헤더 포맷**

```bash
<type>(optional scope): <subject>

* 주의: type은 이모지 붙일 필요없고, 전부 소문자로 작성 가능
ex. `feat:` `fix(login):`
```

## 2. 타입 목록

- `feat` ✨: 사용자 기능 추가
- `fix` 🐛: 버그 수정
- `refactor` ♻️: 기능 변화 없는 리팩터링
- `docs` 📝: 문서 변경
- `test` ✅: 테스트 코드 추가/수정
- `chore` 🔧: 빌드/설정/잡무
- `style` 💄: 포맷/정렬 등 비즈니스 로직 영향 없음
- `perf` ⚡️: 성능 개선
- `ci` 🔁: CI 설정 변경
- `build` 📦: 빌드 시스템 변경
- `revert` ⏪: 이전 커밋 되돌림

## 3. 규칙

- 커밋은 **작고 논리적인 단위**로 나눈다.
- **의도/결과가 드러나는 요약**을 쓴다. (50자 내외 권장)
- WIP 커밋은 PR 올리기 전 **정리/스쿼시**한다.
- 이슈가 있는 작업은 메시지에 **이슈 링크**를 포함한다.

## 4. 예시

```
feat: 예약 결제 API 1차 구현
fix(login): 예약 취소 시 NPE 처리
refactor: 예약 조회 쿼리 최적화
docs: 비동기 아키텍처 소개 문서 추가
```

---

# ✅ 4-3. husky 설정

**반드시 Husky Git Hook을 추가합니다.**

## 1. Husky란?

Husky는 **Git Hooks를 더 쉽고 효율적으로 설정하고 관리할 수 있게 해주는 도구**입니다.
Git Hooks는 특정 Git 이벤트(예: 커밋, 푸시)가 발생하기 전후에 특정 스크립트를 자동으로 실행할 수 있도록 하는 메커니즘인데,
Husky를 사용하면 이러한 Git Hooks를 쉽게 설정하고 공유하여 코드의 일관성과 품질을 유지할 수 있습니다.

## 2. 설치

```
npm install
```

- 이후 `.husky`에 `_` 폴더 생겼는지 확인

## 3. Githook 통제 항목

### 3.1 커밋 전 (pre-commit / commit-msg)

- 코드 스타일 검사 (lint/format)
- 비밀키 포함 여부 검사 (secret scan)
- 커밋 메시지 규칙 검사 및 포맷팅 (type/scope/subject 형식, 이모지 자동 부착)

### 3.2 푸시 전 (pre-push)

- 테스트 및 빌드 통과 여부 확인
- 테스트 커버리지 70% 이상 충족 시에만 푸시 허용

## 4. 훅 스크립트 예시

**전제:** `frontend/`, `backend/` 디렉토리를 사용하는 모노레포 기준 예시입니다. 스크립트 이름은 팀 규칙에 맞게 조정합니다.

### 4.1 `.husky/pre-commit`

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# 코드 스타일 검사
if [ -d "frontend" ]; then (cd frontend && npm run lint && npm run format:check); fi
if [ -d "backend" ]; then (cd backend && npm run lint); fi

# 비밀키 포함 여부 검사 (예: gitleaks 사용)
if command -v gitleaks >/dev/null 2>&1; then
  gitleaks protect --staged
else
  echo "gitleaks 미설치: 설치 후 커밋하세요."
  exit 1
fi
```

### 4.2 `.husky/commit-msg`

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

COMMIT_MESSAGE_FILE_PATH=$1
first_line=$(head -n 1 "$COMMIT_MESSAGE_FILE_PATH")
remaining_lines=$(tail -n +2 "$COMMIT_MESSAGE_FILE_PATH")

# 공동 커밋자(예: Co-authored-by) 트레일러는 원천 차단합니다.
if grep -Eiq '^[[:space:]]*co-authored-by:[[:space:]]*' "$COMMIT_MESSAGE_FILE_PATH"; then
  echo "⛔ 공동 커밋자(Co-authored-by) 트레일러가 포함되어 있어 커밋을 막았습니다."
  echo "   공동 커밋자가 필요한 경우 팀 정책에 따라 수동으로 처리하세요."
  exit 1
fi

# 이미 이모지+타입 형식으로 저장된 커밋(예: amend)이면 건너뜁니다.
case "$first_line" in
  "✨ feat"*)    exit 0 ;;
  "🐛 fix"*)     exit 0 ;;
  "⚡️ perf"*)   exit 0 ;;
  "♻️ refactor"*) exit 0 ;;
  "✅ test"*)    exit 0 ;;
  "📝 docs"*)    exit 0 ;;
  "💄 style"*)   exit 0 ;;
  "🔧 chore"*)   exit 0 ;;
  "🔁 ci"*)      exit 0 ;;
  "📦 build"*)   exit 0 ;;
  "⏪ revert"*)  exit 0 ;;
esac

# Git이 자동 생성하는 메시지는 예외 처리
case "$first_line" in
  Merge*|Revert*|Amend*|Reset*|Rebase*|Tag*)
    exit 0
    ;;
esac

type=$(echo "$first_line" | grep -o "^[A-Za-z]*")
normalized_type=$(echo "$type" | tr 'A-Z' 'a-z')

emoji=""
case "$normalized_type" in
  feat)     emoji="✨" ;;
  fix)      emoji="🐛" ;;
  perf)     emoji="⚡️" ;;
  refactor) emoji="♻️" ;;
  test)     emoji="✅" ;;
  docs)     emoji="📝" ;;
  style)    emoji="💄" ;;
  chore)    emoji="🔧" ;;
  ci)       emoji="🔁" ;;
  build)    emoji="📦" ;;
  revert)   emoji="⏪" ;;
esac

# 유효하지 않은 타입이면 커밋을 막고 가이드를 출력
if [ -z "$emoji" ] || [ -z "$normalized_type" ]; then
  echo "⛔ 올바르지 않은 커밋 타입입니다."
  echo "   사용 가능한 타입:"
  echo "     feat, fix, perf, refactor, test, docs, style, chore, ci, build, revert"
  echo "   예) feat: 기능 추가 설명"
  exit 1
fi

# 첫 번째 단어를 '이모지 + 타입(소문자)' 로 변환
first_line=$(echo "$first_line" | sed "s/^$type/$emoji $normalized_type/")

echo "$first_line" > "$COMMIT_MESSAGE_FILE_PATH"
echo "$remaining_lines" >> "$COMMIT_MESSAGE_FILE_PATH"
```

### 4.3 `.husky/pre-push`

```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

# 테스트/빌드 통과 여부 확인 및 커버리지 기준 충족
if [ -d "frontend" ]; then (cd frontend && npm run test:coverage && npm run build); fi
if [ -d "backend" ]; then (cd backend && npm run test:coverage && npm run build); fi
```

**커버리지 70% 기준은 테스트 스크립트/설정에서 강제**합니다.

<br>

---

<br>

## 변경이력

| 버전 | 일자 | 작성자 | 변경 내역 | 비고 |
|---|---|---|---|---|
| v1.0 | 2026.01.18 | BackendTeam | 문서 초안 작성 | - |
